![image.png](https://pic.leetcode-cn.com/1664418744-JuiZZI-image.png)

**ã€Šä»£ç éšæƒ³å½•ã€‹ç®—æ³•è§†é¢‘å…¬å¼€è¯¾ï¼š[ä¸€èµ·æ“ä½œä¸¤ä¸ªäºŒå‰æ ‘ï¼Ÿæœ‰ç‚¹æ‡µï¼| LeetCodeï¼š617.åˆå¹¶äºŒå‰æ ‘](https://www.bilibili.com/video/BV1m14y1Y7JK)ï¼Œç›¸ä¿¡ç»“åˆè§†é¢‘åœ¨çœ‹æœ¬ç¯‡é¢˜è§£ï¼Œæ›´æœ‰åŠ©äºå¤§å®¶å¯¹æœ¬é¢˜çš„ç†è§£**ã€‚

## æ€è·¯

ç›¸ä¿¡è¿™é“é¢˜ç›®å¾ˆå¤šåŒå­¦ç–‘æƒ‘çš„ç‚¹æ˜¯å¦‚ä½•åŒæ—¶éå†ä¸¤ä¸ªäºŒå‰æ ‘å‘¢ï¼Ÿ

å…¶å®å’Œéå†ä¸€ä¸ªæ ‘é€»è¾‘æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡ä¼ å…¥ä¸¤ä¸ªæ ‘çš„èŠ‚ç‚¹ï¼ŒåŒæ—¶æ“ä½œã€‚

### é€’å½’

äºŒå‰æ ‘ä½¿ç”¨é€’å½’ï¼Œå°±è¦æƒ³ä½¿ç”¨å‰ä¸­åå“ªç§éå†æ–¹å¼ï¼Ÿ

**æœ¬é¢˜ä½¿ç”¨å“ªç§éå†éƒ½æ˜¯å¯ä»¥çš„ï¼**

æˆ‘ä»¬ä¸‹é¢ä»¥å‰åºéå†ä¸ºä¾‹ã€‚

åŠ¨ç”»å¦‚ä¸‹ï¼š

![617.åˆå¹¶äºŒå‰æ ‘](https://pic.leetcode-cn.com/1625884025-SfsUfc-008eGmZEly1gnbjjq8h16g30e20cwnpd.gif)

é‚£ä¹ˆæˆ‘ä»¬æ¥æŒ‰ç…§é€’å½’ä¸‰éƒ¨æ›²æ¥è§£å†³ï¼š

1. **ç¡®å®šé€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ï¼š**

é¦–å…ˆé‚£ä¹ˆè¦åˆå…¥ä¸¤ä¸ªäºŒå‰æ ‘ï¼Œé‚£ä¹ˆå‚æ•°è‡³å°‘æ˜¯è¦ä¼ å…¥ä¸¤ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›å€¼å°±æ˜¯åˆå¹¶ä¹‹åäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* 

```
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
```

2. **ç¡®å®šç»ˆæ­¢æ¡ä»¶ï¼š**

å› ä¸ºæ˜¯ä¼ å…¥äº†ä¸¤ä¸ªæ ‘ï¼Œé‚£ä¹ˆå°±æœ‰ä¸¤ä¸ªæ ‘éå†çš„èŠ‚ç‚¹t1 å’Œ t2ï¼Œå¦‚æœt1 == NULL äº†ï¼Œä¸¤ä¸ªæ ‘åˆå¹¶å°±åº”è¯¥æ˜¯ t2 äº†å•Šï¼ˆå¦‚æœt2ä¹Ÿä¸ºNULLä¹Ÿæ— æ‰€è°“ï¼Œåˆå¹¶ä¹‹åå°±æ˜¯NULLï¼‰ã€‚

åè¿‡æ¥å¦‚æœt2 == NULLï¼Œé‚£ä¹ˆä¸¤ä¸ªæ•°åˆå¹¶å°±æ˜¯t1ï¼ˆå¦‚æœt1ä¹Ÿä¸ºNULLä¹Ÿæ— æ‰€è°“ï¼Œåˆå¹¶ä¹‹åå°±æ˜¯NULLï¼‰ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* 

```
if (t1 == NULL) return t2; // å¦‚æœt1ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t2
if (t2 == NULL) return t1; // å¦‚æœt2ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t1
```

3. **ç¡®å®šå•å±‚é€’å½’çš„é€»è¾‘ï¼š**

å•å±‚é€’å½’çš„é€»è¾‘å°±æ¯”è¾ƒå¥½äº›äº†ï¼Œè¿™é‡Œæˆ‘ä»¬ç”¨é‡å¤åˆ©ç”¨ä¸€ä¸‹t1è¿™ä¸ªæ ‘ï¼Œt1å°±æ˜¯åˆå¹¶ä¹‹åæ ‘çš„æ ¹èŠ‚ç‚¹ï¼ˆå°±æ˜¯ä¿®æ”¹äº†åŸæ¥æ ‘çš„ç»“æ„ï¼‰ã€‚

é‚£ä¹ˆå•å±‚é€’å½’ä¸­ï¼Œå°±è¦æŠŠä¸¤æ£µæ ‘çš„å…ƒç´ åŠ åˆ°ä¸€èµ·ã€‚

* 

```
t1->val += t2->val;
```

æ¥ä¸‹æ¥t1 çš„å·¦å­æ ‘æ˜¯ï¼šåˆå¹¶ t1å·¦å­æ ‘ t2å·¦å­æ ‘ä¹‹åçš„å·¦å­æ ‘ã€‚

t1 çš„å³å­æ ‘ï¼šæ˜¯ åˆå¹¶ t1å³å­æ ‘ t2å³å­æ ‘ä¹‹åçš„å³å­æ ‘ã€‚

æœ€ç»ˆt1å°±æ˜¯åˆå¹¶ä¹‹åçš„æ ¹èŠ‚ç‚¹ã€‚

ä»£ç å¦‚ä¸‹ï¼š

* 

```
t1->left = mergeTrees(t1->left, t2->left);
t1->right = mergeTrees(t1->right, t2->right);
return t1;
```

æ­¤æ—¶å‰åºéå†ï¼Œå®Œæ•´ä»£ç å°±å†™å‡ºæ¥äº†ï¼Œå¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // å¦‚æœt1ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t2
        if (t2 == NULL) return t1; // å¦‚æœt2ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t1
        // ä¿®æ”¹äº†t1çš„æ•°å€¼å’Œç»“æ„
        t1->val += t2->val;                             // ä¸­
        t1->left = mergeTrees(t1->left, t2->left);      // å·¦
        t1->right = mergeTrees(t1->right, t2->right);   // å³
        return t1;
    }
};
```

é‚£ä¹ˆä¸­åºéå†ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // å¦‚æœt1ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t2
        if (t2 == NULL) return t1; // å¦‚æœt2ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t1
        // ä¿®æ”¹äº†t1çš„æ•°å€¼å’Œç»“æ„
        t1->left = mergeTrees(t1->left, t2->left);      // å·¦
        t1->val += t2->val;                             // ä¸­
        t1->right = mergeTrees(t1->right, t2->right);   // å³
        return t1;
    }
};
```

ååºéå†ä¾ç„¶å¯ä»¥ï¼Œä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // å¦‚æœt1ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t2
        if (t2 == NULL) return t1; // å¦‚æœt2ä¸ºç©ºï¼Œåˆå¹¶ä¹‹åå°±åº”è¯¥æ˜¯t1
        // ä¿®æ”¹äº†t1çš„æ•°å€¼å’Œç»“æ„
        t1->left = mergeTrees(t1->left, t2->left);      // å·¦
        t1->right = mergeTrees(t1->right, t2->right);   // å³
        t1->val += t2->val;                             // ä¸­
        return t1;
    }
};
```

**ä½†æ˜¯å‰åºéå†æ˜¯æœ€å¥½ç†è§£çš„ï¼Œæˆ‘å»ºè®®å¤§å®¶ç”¨å‰åºéå†æ¥åšå°±OKã€‚**

å¦‚ä¸Šçš„æ–¹æ³•ä¿®æ”¹äº†t1çš„ç»“æ„ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ä¸ä¿®æ”¹t1å’Œt2çš„ç»“æ„ï¼Œé‡æ–°å®šä¸€ä¸ªæ ‘ã€‚

ä¸ä¿®æ”¹è¾“å…¥æ ‘çš„ç»“æ„ï¼Œå‰åºéå†ï¼Œä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        // é‡æ–°å®šä¹‰æ–°çš„èŠ‚ç‚¹ï¼Œä¸ä¿®æ”¹åŸæœ‰ä¸¤ä¸ªæ ‘çš„ç»“æ„
        TreeNode* root = new TreeNode(0);
        root->val = t1->val + t2->val;
        root->left = mergeTrees(t1->left, t2->left);
        root->right = mergeTrees(t1->right, t2->right);
        return root;
    }
};
```

## è¿­ä»£æ³•

ä½¿ç”¨è¿­ä»£æ³•ï¼Œå¦‚ä½•åŒæ—¶å¤„ç†ä¸¤æ£µæ ‘å‘¢ï¼Ÿ

æ€è·¯æˆ‘ä»¬åœ¨[äºŒå‰æ ‘ï¼šæˆ‘å¯¹ç§°ä¹ˆï¼Ÿ](https://programmercarl.com/0101.å¯¹ç§°äºŒå‰æ ‘.html)ä¸­çš„è¿­ä»£æ³•å·²ç»è®²è¿‡ä¸€æ¬¡äº†ï¼Œæ±‚äºŒå‰æ ‘å¯¹ç§°çš„æ—¶å€™å°±æ˜¯æŠŠä¸¤ä¸ªæ ‘çš„èŠ‚ç‚¹åŒæ—¶åŠ å…¥é˜Ÿåˆ—è¿›è¡Œæ¯”è¾ƒã€‚

æœ¬é¢˜æˆ‘ä»¬ä¹Ÿä½¿ç”¨é˜Ÿåˆ—ï¼Œæ¨¡æ‹Ÿçš„å±‚åºéå†ï¼Œä»£ç å¦‚ä¸‹ï¼š

* CPP

```CPP
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        queue<TreeNode*> que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) {
            TreeNode* node1 = que.front(); que.pop();
            TreeNode* node2 = que.front(); que.pop();
            // æ­¤æ—¶ä¸¤ä¸ªèŠ‚ç‚¹ä¸€å®šä¸ä¸ºç©ºï¼Œvalç›¸åŠ 
            node1->val += node2->val;

            // å¦‚æœä¸¤æ£µæ ‘å·¦èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼ŒåŠ å…¥é˜Ÿåˆ—
            if (node1->left != NULL && node2->left != NULL) {
                que.push(node1->left);
                que.push(node2->left);
            }
            // å¦‚æœä¸¤æ£µæ ‘å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼ŒåŠ å…¥é˜Ÿåˆ—
            if (node1->right != NULL && node2->right != NULL) {
                que.push(node1->right);
                que.push(node2->right);
            }

            // å½“t1çš„å·¦èŠ‚ç‚¹ ä¸ºç©º t2å·¦èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œå°±èµ‹å€¼è¿‡å»
            if (node1->left == NULL && node2->left != NULL) {
                node1->left = node2->left;
            }
            // å½“t1çš„å³èŠ‚ç‚¹ ä¸ºç©º t2å³èŠ‚ç‚¹ä¸ä¸ºç©ºï¼Œå°±èµ‹å€¼è¿‡å»
            if (node1->right == NULL && node2->right != NULL) {
                node1->right = node2->right;
            }
        }
        return t1;
    }
};
```

## æ‹“å±•

å½“ç„¶ä¹Ÿå¯ä»¥ç§€ä¸€æ³¢æŒ‡é’ˆçš„æ“ä½œï¼Œè¿™æ˜¯æˆ‘å†™çš„é‡è·¯å­ï¼Œå¤§å®¶å°±éšä¾¿çœ‹çœ‹å°±è¡Œäº†ï¼Œä»¥é˜²å¸¦è·‘éäº†ã€‚

å¦‚ä¸‹ä»£ç ä¸­ï¼Œæƒ³è¦æ›´æ”¹äºŒå‰æ ‘çš„å€¼ï¼Œåº”è¯¥ä¼ å…¥æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆã€‚

ä»£ç å¦‚ä¸‹ï¼šï¼ˆå‰åºéå†ï¼‰

* CPP

```CPP
class Solution {
public:
    void process(TreeNode** t1, TreeNode** t2) {
        if ((*t1) == NULL && (*t2) == NULL) return;
        if ((*t1) != NULL && (*t2) != NULL) {
            (*t1)->val += (*t2)->val;
        }
        if ((*t1) == NULL && (*t2) != NULL) {
            *t1 = *t2;
            return;
        }
        if ((*t1) != NULL && (*t2) == NULL) {
            return;
        }
        process(&((*t1)->left), &((*t2)->left));
        process(&((*t1)->right), &((*t2)->right));
    }
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        process(&t1, &t2);
        return t1;
    }
};
```

## æ€»ç»“

åˆå¹¶äºŒå‰æ ‘ï¼Œä¹Ÿæ˜¯äºŒå‰æ ‘æ“ä½œçš„ç»å…¸é¢˜ç›®ï¼Œå¦‚æœæ²¡æœ‰æ¥è§¦è¿‡çš„è¯ï¼Œå…¶å®å¹¶ä¸ç®€å•ï¼Œå› ä¸ºæˆ‘ä»¬ä¹ æƒ¯äº†æ“ä½œä¸€ä¸ªäºŒå‰æ ‘ï¼Œä¸€èµ·æ“ä½œä¸¤ä¸ªäºŒå‰æ ‘ï¼Œè¿˜ä¼šæœ‰ç‚¹æ‡µæ‡µçš„ã€‚

è¿™ä¸æ˜¯æˆ‘ä»¬ç¬¬ä¸€æ¬¡æ“ä½œä¸¤æ£µäºŒå‰æ ‘äº†ï¼Œåœ¨[äºŒå‰æ ‘ï¼šæˆ‘å¯¹ç§°ä¹ˆï¼Ÿ](https://programmercarl.com/0101.å¯¹ç§°äºŒå‰æ ‘.html)ä¸­ä¹Ÿä¸€èµ·æ“ä½œäº†ä¸¤æ£µäºŒå‰æ ‘ã€‚

è¿­ä»£æ³•ä¸­ï¼Œä¸€èˆ¬ä¸€èµ·æ“ä½œä¸¤ä¸ªæ ‘éƒ½æ˜¯ä½¿ç”¨é˜Ÿåˆ—æ¨¡æ‹Ÿç±»ä¼¼å±‚åºéå†ï¼ŒåŒæ—¶å¤„ç†ä¸¤ä¸ªæ ‘çš„èŠ‚ç‚¹ï¼Œè¿™ç§æ–¹å¼æœ€å¥½ç†è§£ï¼Œå¦‚æœç”¨æ¨¡æ‹Ÿé€’å½’çš„æ€è·¯çš„è¯ï¼Œè¦å¤æ‚ä¸€äº›ã€‚

æœ€åæ‹“å±•ä¸­ï¼Œæˆ‘ç»™äº†ä¸€ä¸ªæ“ä½œæŒ‡é’ˆçš„é‡è·¯å­ï¼Œå¤§å®¶éšä¾¿çœ‹çœ‹å°±è¡Œäº†ï¼Œå¦‚æœå­¦ä¹ C++çš„è¯ï¼Œå¯ä»¥åœ¨å»ç ”ç©¶ç ”ç©¶ã€‚

## å…¶ä»–è¯­è¨€ç‰ˆæœ¬

* []

```Java
class Solution {
    // é€’å½’
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2;
        if (root2 == null) return root1;

        root1.val += root2.val;
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);
        return root1;
    }
}

class Solution {
    // ä½¿ç”¨æ ˆè¿­ä»£
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) {
            return root2;
        }
        if (root2 == null) {
            return root1;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root2);
        stack.push(root1);
        while (!stack.isEmpty()) {
            TreeNode node1 = stack.pop();
            TreeNode node2 = stack.pop();
            node1.val += node2.val;
            if (node2.right != null && node1.right != null) {
                stack.push(node2.right);
                stack.push(node1.right);
            } else {
                if (node1.right == null) {
                    node1.right = node2.right;
                }
            }
            if (node2.left != null && node1.left != null) {
                stack.push(node2.left);
                stack.push(node1.left);
            } else {
                if (node1.left == null) {
                    node1.left = node2.left;
                }
            }
        }
        return root1;
    }
}

class Solution {
    // ä½¿ç”¨é˜Ÿåˆ—è¿­ä»£
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null) return root2;
        if (root2 ==null) return root1;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root1);
        queue.offer(root2);
        while (!queue.isEmpty()) {
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();
            // æ­¤æ—¶ä¸¤ä¸ªèŠ‚ç‚¹ä¸€å®šä¸ä¸ºç©ºï¼Œvalç›¸åŠ 
            node1.val = node1.val + node2.val;
            // å¦‚æœä¸¤æ£µæ ‘å·¦èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼ŒåŠ å…¥é˜Ÿåˆ—
            if (node1.left != null && node2.left != null) {
                queue.offer(node1.left);
                queue.offer(node2.left);
            }
            // å¦‚æœä¸¤æ£µæ ‘å³èŠ‚ç‚¹éƒ½ä¸ä¸ºç©ºï¼ŒåŠ å…¥é˜Ÿåˆ—
            if (node1.right != null && node2.right != null) {
                queue.offer(node1.right);
                queue.offer(node2.right);
            }
            // è‹¥node1çš„å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œç›´æ¥èµ‹å€¼
            if (node1.left == null && node2.left != null) {
                node1.left = node2.left;
            }
            // è‹¥node2çš„å·¦èŠ‚ç‚¹ä¸ºç©ºï¼Œç›´æ¥èµ‹å€¼
            if (node1.right == null && node2.right != null) {
                node1.right = node2.right;
            }
        }
        return root1;
    }
}
```

* []

```python
# **é€’å½’æ³• - å‰åºéå†**
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        # é€’å½’ç»ˆæ­¢æ¡ä»¶: 
        #  ä½†å‡¡æœ‰ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©º, å°±ç«‹åˆ»è¿”å›å¦å¤–ä¸€ä¸ª. å¦‚æœå¦å¤–ä¸€ä¸ªä¹Ÿä¸ºNoneå°±ç›´æ¥è¿”å›None. 
        if not root1: 
            return root2
        if not root2: 
            return root1
        # ä¸Šé¢çš„é€’å½’ç»ˆæ­¢æ¡ä»¶ä¿è¯äº†ä»£ç æ‰§è¡Œåˆ°è¿™é‡Œroot1, root2éƒ½éç©º. 
        root1.val += root2.val # ä¸­
        root1.left = self.mergeTrees(root1.left, root2.left) #å·¦
        root1.right = self.mergeTrees(root1.right, root2.right) # å³
        
        return root1 # âš ï¸ æ³¨æ„: æœ¬é¢˜æˆ‘ä»¬é‡å¤ä½¿ç”¨äº†é¢˜ç›®ç»™å‡ºçš„èŠ‚ç‚¹è€Œä¸æ˜¯åˆ›å»ºæ–°èŠ‚ç‚¹. èŠ‚çœæ—¶é—´, ç©ºé—´. 

# **è¿­ä»£æ³•**
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1: 
            return root2
        if not root2: 
            return root1

        queue = deque()
        queue.append(root1)
        queue.append(root2)

        while queue: 
            node1 = queue.popleft()
            node2 = queue.popleft()
            # æ›´æ–°queue
            # åªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹éƒ½æœ‰å·¦èŠ‚ç‚¹æ—¶, å†å¾€queueé‡Œé¢æ”¾.
            if node1.left and node2.left: 
                queue.append(node1.left)
                queue.append(node2.left)
            # åªæœ‰ä¸¤ä¸ªèŠ‚ç‚¹éƒ½æœ‰å³èŠ‚ç‚¹æ—¶, å†å¾€queueé‡Œé¢æ”¾.
            if node1.right and node2.right: 
                queue.append(node1.right)
                queue.append(node2.right)

            # æ›´æ–°å½“å‰èŠ‚ç‚¹. åŒæ—¶æ”¹å˜å½“å‰èŠ‚ç‚¹çš„å·¦å³å­©å­. 
            node1.val += node2.val
            if not node1.left and node2.left: 
                node1.left = node2.left
            if not node1.right and node2.right: 
                node1.right = node2.right

        return root1
```

* []

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
 //å‰åºéå†ï¼ˆé€’å½’éå†ï¼Œè·Ÿ105 106å·®ä¸å¤šçš„æ€è·¯ï¼‰
func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    var value int 
    var nullNode *TreeNode//ç©ºnodeï¼Œä¾¿äºéå†
    nullNode=&TreeNode{
        Val:0,
        Left:nil,
        Right:nil}
    switch {
        case t1==nil&&t2==nil: return nil//ç»ˆæ­¢æ¡ä»¶
        default : //å¦‚æœå…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºï¼Œåˆ™å°†è¯¥èŠ‚ç‚¹ç½®ä¸ºnullNodeï¼Œæ–¹ä¾¿ä¸‹æ¬¡éå†
        if t1==nil{
            value=t2.Val
            t1=nullNode
        }else if t2==nil{
            value=t1.Val
            t2=nullNode
        }else {
            value=t1.Val+t2.Val
        }
    }
    root:=&TreeNode{//æ„é€ æ–°çš„äºŒå‰æ ‘
        Val: value,
        Left: mergeTrees(t1.Left,t2.Left),
        Right: mergeTrees(t1.Right,t2.Right)}
    return root
}

// å‰åºéå†ç®€æ´ç‰ˆ
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
    if root1 == nil {
        return root2
    }
    if root2 == nil {
        return root1
    }
    root1.Val += root2.Val
    root1.Left = mergeTrees(root1.Left, root2.Left)
    root1.Right = mergeTrees(root1.Right, root2.Right)
    return root1
}

// è¿­ä»£ç‰ˆæœ¬
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
    queue := make([]*TreeNode,0)
    if root1 == nil{
        return root2
    }
    if root2 == nil{
        return root1
    }
    queue = append(queue,root1)
    queue = append(queue,root2)

    for size:=len(queue);size>0;size=len(queue){
        node1 := queue[0]
        queue = queue[1:]
        node2 := queue[0]
        queue = queue[1:]
        node1.Val += node2.Val
        // å·¦å­æ ‘éƒ½ä¸ä¸ºç©º
        if node1.Left != nil && node2.Left != nil{
            queue = append(queue,node1.Left)
            queue = append(queue,node2.Left)
        }
        // å³å­æ ‘éƒ½ä¸ä¸ºç©º
        if node1.Right !=nil && node2.Right !=nil{
            queue = append(queue,node1.Right)
            queue = append(queue,node2.Right)
        }
        // æ ‘ 1 çš„å·¦å­æ ‘ä¸º nilï¼Œç›´æ¥æ¥ä¸Šæ ‘ 2 çš„å·¦å­æ ‘
        if node1.Left == nil{
            node1.Left = node2.Left
        }
        // æ ‘ 1 çš„å³å­æ ‘ä¸º nilï¼Œç›´æ¥æ¥ä¸Šæ ‘ 2 çš„å³å­æ ‘
        if node1.Right == nil{
            node1.Right = node2.Right
        }
    }
    return root1
}
```

* []

```javascript
// > é€’å½’æ³•ï¼š

var mergeTrees = function (root1, root2) {
    const preOrder = (root1, root2) => {
        if (!root1)
            return root2
        if (!root2)
            return root1;
        root1.val += root2.val;
        root1.left = preOrder(root1.left, root2.left);
        root1.right = preOrder(root1.right, root2.right);
        return root1;
    }
    return preOrder(root1, root2);
};

// > è¿­ä»£æ³•ï¼š

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function(root1, root2) {
    if (root1 === null) return root2;
    if (root2 === null) return root1;

    let queue = [];
    queue.push(root1);
    queue.push(root2);
    while (queue.length) {
        let node1 = queue.shift();
        let node2 = queue.shift();;
        node1.val += node2.val;
        if (node1.left !== null && node2.left !== null) {
            queue.push(node1.left);
            queue.push(node2.left);
        }
        if (node1.right !== null && node2.right !== null) {
            queue.push(node1.right);
            queue.push(node2.right);
        }
        if (node1.left === null && node2.left !== null) {
            node1.left = node2.left;
        }
        if (node1.right === null && node2.right !== null) {
            node1.right = node2.right;
        } 
    }
    return root1;
};

```

* []

```typescript
function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
    if (root1 === null) return root2;
    if (root2 === null) return root1;
    const resNode: TreeNode = new TreeNode(root1.val + root2.val);
    resNode.left = mergeTrees(root1.left, root2.left);
    resNode.right = mergeTrees(root1.right, root2.right);
    return resNode;
};

// > è¿­ä»£æ³•ï¼š
function mergeTrees(root1: TreeNode | null, root2: TreeNode | null): TreeNode | null {
    if (root1 === null) return root2;
    if (root2 === null) return root1;
    const helperQueue1: TreeNode[] = [],
        helperQueue2: TreeNode[] = [];
    helperQueue1.push(root1);
    helperQueue2.push(root2);
    let tempNode1: TreeNode,
        tempNode2: TreeNode;
    while (helperQueue1.length > 0) {
        tempNode1 = helperQueue1.shift()!;
        tempNode2 = helperQueue2.shift()!;
        tempNode1.val += tempNode2.val;
        if (tempNode1.left !== null && tempNode2.left !== null) {
            helperQueue1.push(tempNode1.left);
            helperQueue2.push(tempNode2.left);
        } else if (tempNode1.left === null) {
            tempNode1.left = tempNode2.left;
        }
        if (tempNode1.right !== null && tempNode2.right !== null) {
            helperQueue1.push(tempNode1.right);
            helperQueue2.push(tempNode2.right);
        } else if (tempNode1.right === null) {
            tempNode1.right = tempNode2.right;
        }
    }
    return root1;
};
```

* []

```scala
// é€’å½’:
object Solution {
  def mergeTrees(root1: TreeNode, root2: TreeNode): TreeNode = {
    if (root1 == null) return root2 // å¦‚æœroot1ä¸ºç©ºï¼Œè¿”å›root2
    if (root2 == null) return root1 // å¦‚æœroot2ä¸ºç©ºï¼Œè¿”å›root1
    // æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå€¼ä¸ºä¸¤ä¸ªèŠ‚ç‚¹çš„å’Œ
    var node = new TreeNode(root1.value + root2.value)
    // å¾€ä¸‹é€’å½’
    node.left = mergeTrees(root1.left, root2.left)
    node.right = mergeTrees(root1.right, root2.right)
    node // è¿”å›nodeï¼Œreturnå…³é”®å­—å¯ä»¥çœç•¥
  }
}

// è¿­ä»£:

object Solution {
  import scala.collection.mutable
  def mergeTrees(root1: TreeNode, root2: TreeNode): TreeNode = {
    if (root1 == null) return root2
    if (root2 == null) return root1
    var stack = mutable.Stack[TreeNode]()
    // å…ˆæ”¾node2å†æ”¾node1
    stack.push(root2)
    stack.push(root1)
    while (!stack.isEmpty) {
      var node1 = stack.pop()
      var node2 = stack.pop()
      node1.value += node2.value
      if (node1.right != null && node2.right != null) {
        stack.push(node2.right)
        stack.push(node1.right)
      } else {
        if(node1.right == null){
          node1.right = node2.right
        }
      }
      if (node1.left != null && node2.left != null) {
        stack.push(node2.left)
        stack.push(node1.left)
      } else {
        if(node1.left == null){
          node1.left = node2.left
        }
      }
    }
    root1
  }
}
```

# äºŒå‰æ ‘åŠ›æ‰£é¢˜ç›®æ€»ç»“

æŒ‰ç…§å¦‚ä¸‹é¡ºåºåˆ·åŠ›æ‰£ä¸Šçš„é¢˜ç›®ï¼Œç›¸ä¿¡ä¼šå¸®ä½ åœ¨å­¦ä¹ äºŒå‰æ ‘çš„è·¯ä¸Šå°‘èµ°å¾ˆå¤šå¼¯è·¯ã€‚ä»¥ä¸‹æ¯é“é¢˜ç›®åœ¨åŠ›æ‰£é¢˜è§£åŒºéƒ½æœ‰ã€Œä»£ç éšæƒ³å½•ã€çš„é¢˜è§£ã€‚

![image.png](https://pic.leetcode-cn.com/1625557068-rTzCSW-image.png)

------------

å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ç¨‹åºå‘˜Carlï¼Œå¦‚æœä½ è¿˜åœ¨æ²¡æœ‰ç« æ³•çš„åˆ·é¢˜ï¼Œ**å»ºè®®æŒ‰ç…§[ä»£ç éšæƒ³å½•åˆ·é¢˜è·¯çº¿](https://programmercarl.com/)æ¥åˆ·**ï¼Œå¹¶æä¾›[PDFä¸‹è½½](https://programmercarl.com/other/algo_pdf.html)ï¼Œåˆ·é¢˜è·¯çº¿åŒæ—¶ä¹Ÿå¼€æºåœ¨[Github](https://github.com/youngyangyang04/leetcode-master)ä¸Šï¼Œä½ ä¼šå‘ç°è¯¦è§å¾ˆæ™šï¼

**å¦‚æœæ„Ÿè§‰é¢˜è§£å¯¹ä½ æœ‰å¸®åŠ©ï¼Œä¸è¦åå•¬ç»™ä¸€ä¸ªğŸ‘å§ï¼**
